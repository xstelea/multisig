# Multisig Orchestrator — Implementation Progress

## Issue 1: Project scaffolding + access rule display ✅
Completed: 2026-02-23
Commit: b2f686a

### What was built

**Backend (multisig-server/)**
- Rust/axum HTTP server on configurable port
- PostgreSQL connection pool (sqlx) + empty initial migration
- CORS configuration for frontend origin
- GatewayClient module:
  - read_access_rule(account_address) — fetches from /state/entity/details, parses role_assignments.owner.rule
  - get_current_epoch() — from /status/gateway-status
  - Handles CountOf (N-of-M), Require (single signer), AllOf, AnyOf proof rules
- GET /health endpoint
- GET /account/access-rule endpoint returning { signers: [{ key_hash, key_type, badge_resource, badge_local_id }], threshold }
- Config via env vars: PORT, DATABASE_URL, GATEWAY_URL, MULTISIG_ACCOUNT_ADDRESS, FRONTEND_ORIGIN
- Unit tests: 4 tests for access rule parsing (CountOf, Require, AllowAll, DenyAll)
- Integration tests: 2 #[ignore] tests against live Stokenet

**Frontend (multisig-app/)**
- TanStack Start + React 19 + Tailwind CSS v4
- Effect runtime setup (Atom.context + global logger layer)
- Radix dApp Toolkit initialization (connect button, network config)
- OrchestratorClient Effect service (health, getAccessRule)
- Home page displaying:
  - Connected wallet state (reactive via RxJS→Effect stream bridge)
  - Multisig account address
  - Current signers with key hashes
  - Required threshold (e.g. "3 of 4 signatures required")

### Test multisig account
account_tdx_2_1cx3u3xgr9anc9fk54dxzsz6k2n6lnadludkx4mx5re5erl8jt9lpnp (3-of-4, created via POC)

### Notes
- Gateway API returns key HASHES (not raw public keys) in access rule NonFungibleGlobalId local_ids
- Public keys will be recovered when signers connect wallets or sign (Issue 3)
- The .env file for the frontend is gitignored; copy .env.example for backend config

## Issue 2: Create & view proposals ✅
Completed: 2026-02-23

### What was built

**Database:**
- `proposals` table migration (002_proposals.sql): id, manifest_text, treasury_account, epoch_min/max, status (enum with 8 states), subintent_hash, intent_discriminator, partial_transaction_bytes, created_at, submitted_at, tx_id
- Indexes on status and created_at

**Backend (multisig-server/):**
- Added Radix SDK deps: radix-common 1.3, radix-transactions 1.3, rand, hex
- ProposalStore module — PostgreSQL-backed CRUD with state machine:
  - create(), get(id), list(), transition_status(id, from, to)
  - ProposalStatus enum with validated transitions: Created→Signing→Ready→Submitting→Committed|Failed, plus →Expired/→Invalid from active states
  - Runtime-checked queries (sqlx::query_as with FromRow) — no compile-time DB dependency
- TransactionBuilder module — builds unsigned subintents from raw manifest text:
  - build_unsigned_subintent(manifest_text, network_id, epoch_min, epoch_max) using Radix SDK
  - Compiles RTM string to SubintentManifestV2 via radix_transactions::manifest::compiler
  - Appends YIELD_TO_PARENT automatically if not present
  - Cryptographically random intent_discriminator (rand::thread_rng)
  - Returns bech32-encoded SubintentHash (subtxid_...) + serialized PartialTransactionV2 bytes
  - Deterministic variant for testing with explicit discriminator
- API endpoints:
  - POST /proposals — accepts { manifest_text, expiry_epoch }, fetches current epoch from Gateway, builds unsigned subintent, stores in DB
  - GET /proposals — list all proposals ordered by created_at DESC
  - GET /proposals/:id — full proposal detail
- New env var: NETWORK_ID (default: 2 for Stokenet)
- AppState refactored: pool replaced with Arc<ProposalStore>, added network_id
- Unit tests: 4 state machine tests + 5 transaction builder tests (offline, deterministic)

**Frontend (multisig-app/):**
- OrchestratorClient — added createProposal(), listProposals(), getProposal(id) with Effect Schema validation
- ProposalSchema for API response parsing (id, manifest_text, status, epoch range, subintent_hash, etc.)
- Proposal atoms (proposalAtoms.ts): proposalListAtom, createProposalAtom (with list refresh), makeProposalDetailAtom(id)
- Home page updated:
  - "New Proposal" button linking to /proposals/new
  - Proposal list section with status badges (color-coded by state), epoch range, created date
  - Links to proposal detail pages
- Create Proposal page (/proposals/new):
  - Textarea for raw RTM manifest text
  - Epoch expiry input
  - Form validation + error display
  - On success: redirects to proposal detail page
- Proposal Detail page (/proposals/$id):
  - Status badge, UUID, metadata grid (created date, epoch window, subintent hash)
  - Full manifest text display in monospace code block

### Tests
- 13 unit tests pass (4 gateway + 4 proposal store state machine + 5 transaction builder)
- 2 integration tests (#[ignore]) for live Stokenet
- Frontend TypeScript types pass with no errors

## Issue 3: Collect signatures ✅
Completed: 2026-02-23

### What was built

**Database:**
- `signatures` table migration (003_signatures.sql): id, proposal_id (FK), signer_public_key, signer_key_hash, signature_bytes, signed_partial_transaction_hex, created_at
- UNIQUE constraint on (proposal_id, signer_key_hash) to prevent duplicate signatures
- Index on proposal_id for fast lookups

**Backend (multisig-server/):**
- SignatureCollector module (signature_collector.rs):
  - `extract_signature_from_hex()` — decodes wallet's SignedPartialTransactionV2 hex, extracts Ed25519 signature + public key
  - `compute_key_hash()` — Ed25519 public key → 29-byte Blake2b hash (matches Gateway API's NonFungibleGlobalId local_id format)
  - `find_signer_by_hash()` — validates extracted key hash against access rule signers
  - `SignatureCollector::add_signature()` — full validation pipeline: extract sig → compute hash → check access rule → check proposal state → store (UNIQUE prevents dupes) → state transitions
  - `SignatureCollector::get_signature_status()` — returns threshold progress, per-signer signed/pending status
  - State transitions: Created→Signing on first sig, Signing→Ready when threshold met
- API endpoints:
  - POST /proposals/{id}/sign — accepts { signed_partial_transaction_hex }, validates and stores signature
  - GET /proposals/{id}/signatures — returns signature collection progress
- 10 unit tests: key hash computation, signature extraction from real SDK-built signed partials, signer validation accept/reject

**Frontend (multisig-app/):**
- OrchestratorClient — added signProposal() and getSignatureStatus() with Effect Schema validation
- Proposal atoms — makeSignatureStatusAtom(id), makeSignProposalAtom (calls sign + refreshes all related atoms)
- Proposal detail page updated:
  - Signature progress section with progress bar (collected/threshold)
  - Per-signer list with green/gray dot indicators (Signed/Pending)
  - Sign button using SubintentRequestBuilder → sendPreAuthorizationRequest → posts signed partial to backend
  - Wallet connection state handling

### Architecture notes
- Each wallet sendPreAuthorizationRequest creates a NEW subintent with random discriminator — cannot get multiple signatures on same hash
- Pragmatic solution: store each signer's full signed_partial_transaction_hex, extract only signature + public key for validation
- Reconstruction of a single properly-signed subintent for the main transaction deferred to Issue 4

### Tests
- 23 unit tests pass (4 gateway + 4 proposal store + 5 transaction builder + 10 signature collector)
- Frontend TypeScript types pass cleanly

## Issue 4: Submit transaction ✅
Completed: 2026-02-23

### What was built

**Database:**
- `submission_attempts` table migration (004_submission_attempts.sql): id, proposal_id (FK), fee_payer_account, tx_hash, status, error_message, created_at
- Index on proposal_id for audit trail lookups

**Backend (multisig-server/):**
- GatewayClient — 3 new methods:
  - `submit_transaction(notarized_transaction_hex)` — POST to Gateway /transaction/submit
  - `get_transaction_status(intent_hash)` — POST to /transaction/status
  - `wait_for_commit(intent_hash, max_attempts)` — async polling loop (2s intervals), handles CommittedSuccess/CommittedFailure/Rejected
- TransactionBuilder — 4 new functions:
  - `reconstruct_signed_partial(partial_bytes, signatures)` — deserializes stored unsigned partial, attaches all collected Ed25519 signatures
  - `compose_main_transaction(network_id, epoch, fee_signed_partial, withdrawal_signed_partial)` — builds NotarizedTransactionV2 with ephemeral notary key, two child subintents (fee_payment + withdrawal), YIELD_TO_CHILD orchestration
  - `build_fee_manifest(fee_payer_account, lock_fee_amount)` — generates RTM manifest text for fee payer to sign
  - `compose_main_transaction_with_discriminator()` — deterministic variant for testing
- ProposalStore — 2 new methods:
  - `get_partial_transaction_bytes(id)` — fetches raw stored partial bytes
  - `update_tx_id(id, tx_id)` — sets tx_id + submitted_at after submission
  - `record_submission_attempt()` — audit trail for each submission attempt
- SignatureCollector — 1 new method:
  - `get_raw_signatures(proposal_id)` — returns (public_key_hex, signature_bytes) pairs for transaction reconstruction
- API endpoints:
  - POST /proposals/{id}/prepare — validates Ready state, returns fee manifest text for wallet signing
  - POST /proposals/{id}/submit — decodes fee payment hex, reconstructs withdrawal signed partial, composes NotarizedTransactionV2, transitions Ready→Submitting, submits to Gateway, polls for commit, transitions to Committed or Failed

**Frontend (multisig-app/):**
- OrchestratorClient — added prepareSubmission() and submitProposal() with Effect Schema validation
- Proposal atoms — makePrepareSubmissionAtom(id), makeSubmitProposalAtom (calls submit + refreshes proposal detail/list)
- Proposal detail page updated:
  - SubmitSection component (shown when status=ready): 3-step flow with progress feedback
    1. Calls prepare endpoint with fee_payer_account
    2. Sends fee manifest to wallet via sendPreAuthorizationRequest
    3. Calls submit endpoint with signed fee payment hex
  - TransactionResult component (shown when committed/failed): tx_id display, submitted_at timestamp

### Architecture decisions
- Wallet sendTransaction() compiles+signs+notarizes+submits — cannot include pre-signed child subintents
- Solution: fee payer signs fee subintent via sendPreAuthorizationRequest; backend composes full NotarizedTransactionV2 with TWO children (fee + withdrawal) and ephemeral notary key
- Original unsigned partial (stored at proposal creation) + all collected signatures = properly reconstructed SignedPartialTransactionV2 for the main TX
- Server notarizes with notary_is_signatory: false (ephemeral key, no on-ledger role)

### Tests
- 28 unit tests pass (4 gateway + 4 proposal store + 10 transaction builder + 10 signature collector)
- 5 new transaction builder tests: reconstruct_signed_partial, compose_main_transaction valid output, different discriminators, build_fee_manifest, reconstruct rejects wrong key
- Frontend TypeScript types pass cleanly

## Issue 5: Validity monitoring
Status: Not started
